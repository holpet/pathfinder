{"version":3,"sources":["app/header/NodeMuster.js","app/header/AlgoText.js","app/header/Header.js","pathfinder/gridView/NodeView.jsx","pathfinder/gridView/MouseHandler.jsx","pathfinder/gridView/GridView.jsx","pathfinder/grid/Node.js","pathfinder/mazes/StairGenerator.js","pathfinder/mazes/MazeGenerator.js","pathfinder/algos/BreadthFS.js","pathfinder/algos/Dijkstra.js","pathfinder/algos/DepthFS.js","pathfinder/algos/Astar.js","pathfinder/algos/BestFS.js","pathfinder/gridView/algoAnimator.js","app/App.js","pathfinder/grid/Grid.js","app/serviceWorker.js","index.js","img/dot_full.svg","img/start.svg","img/flag.svg","img/hold.svg"],"names":["renderNodeMuster","type","locator","classAs","idAs","key","NodeMuster","props","state","className","this","id","loc","src","bgSVG","draggable","alt","startSVG","endSVG","weightSVG","setImgLocator","PureComponent","algoText","algoType","text","name","desc","dijkstraText","astarText","bestfsText","breadthfsText","depthfsText","Header","clickedAlgo","musters","nodeMuster","push","makeArrayMuster","weightAv","isWeightAvailable","weighted","Navbar","bg","variant","expand","Text","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Item","onClick","algoSelected","setState","console","log","Link","generateMaze","generateStairs","clearBoard","algo","href","OverlayTrigger","placement","overlay","Tooltip","bsPrefix","Component","NodeView","clearNodeView","clear","handleUserChanges","event","mouseEvents","gridView","gridUpdate","row","col","nodeID","generated","isWall","noHover","nextProps","setDict","cls","setHover","onMouseUp","onMouseDown","onMouseOver","onMouseEnter","onMouseLeave","mouseHandler","node","grid","mouseIsPressed","currentLocator","currentType","currentID","ctrlKey","prevSqID","getFirstItemFromLL","prevSq","dict","shiftFirstItemFromLL","algoDisplayed","algoRecalculate","addItemToLL","GridView","getDict","count","setRef","ref","getStartNode","value","linkedList","LinkedList","unshift","first","shift","gridMax","i","j","st_row","st_col","en_row","en_col","locatorProp","start_row","start_col","end_row","end_col","setLocators","num_i","Math","floor","window","screen","width","num_j","height","getRowCol","maxCol","maxRow","getLocators","countNodeID","nodeRows","renderNode","ctn","createNode","distance","Infinity","totalDistance","isVisited","previousNode","checkLocator","isValidOnBoard","getRandomNum","min","max","random","heuristic","end","abs","animateGenerated","mappedWalls","notActive","setTimeout","document","getElementById","classList","add","length","deanimateGeneratedAfter","animWallList","getElementsByClassName","remove","clearClasses","handEl","finalPath","mappedSearch","mappedLength","finalPathLength","App","prepareAlgo","clearGridBeforeAlgo","pathArrays","start","mappedFunction","PQ","Heap","obj1","obj2","mapped","dr","dc","distCounter","size","pop","neighbour","foundEnd","solveDijkstra","pathMapped","reverse","reconstructPath","dijkstra","foundE","neighbourDistance","currentDistance","solveAstar","Astar","solveBestFS","bestFS","Q","Queue","enqueue","dequeue","solveBFS","breadthFS","mapSearch","solveDFS","adjList","neighbourList","adj","AL","obj","orig","k","adjacencyDFS","depthFS","startAlgo","animateSearch","animatePath","recalculateAlgo","recalcAlgo","chooseAlgo","isWeightOnGrid","clearGrid","weightedAlgo","mappedAr","stairs","stairsMapped","stairsGrid","mappedMaze","stack","Stack","check","randRow","randCol","current","availableNeighbours","nextNode","joiningNode","randomizedMaze","mazeMapped","mazeGrid","gridInit","newGrid","initializeGrid","setGrid","slice","newNode","a","gridRef","createRef","Boolean","location","hostname","match","positions","BOTTOM_CENTER","transitions","SCALE","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","module","exports"],"mappings":"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","file":"static/js/main.6600910f.chunk.js","sourcesContent":["import React, { PureComponent } from \"react\";\r\nimport \"./NodeMuster.css\";\r\nimport startSVG from \"../../img/start.svg\";\r\nimport endSVG from \"../../img/flag.svg\";\r\nimport bgSVG from \"../../img/dot_full.svg\";\r\nimport weightSVG from \"../../img/hold.svg\";\r\n\r\nfunction renderNodeMuster(type, locator, classAs, idAs) {\r\n  return (\r\n    <NodeMuster\r\n      key={idAs} // unique identification for React components (returns undefined if called)\r\n      type={type}\r\n      locator={locator}\r\n      classAs={classAs}\r\n      idAs={idAs}\r\n    />\r\n  );\r\n}\r\n\r\nexport const makeArrayMuster = () => {\r\n  var nodeMuster = [];\r\n  // start & end\r\n  nodeMuster.push(\r\n    renderNodeMuster(\"norm\", \"start\", \"muster-start muster-not-active\", \"start\")\r\n  );\r\n  nodeMuster.push(\r\n    renderNodeMuster(\"norm\", \"end\", \"muster-end muster-not-active\", \"end\")\r\n  );\r\n  // wall & weight\r\n  nodeMuster.push(\r\n    renderNodeMuster(\"norm\", \"wall\", \"muster-wall muster-not-active\", \"wall\")\r\n  );\r\n  nodeMuster.push(\r\n    renderNodeMuster(\r\n      \"norm\",\r\n      \"weight\",\r\n      \"muster-weight muster-not-active\",\r\n      \"weight\"\r\n    )\r\n  );\r\n  // final path & visited & unvisited\r\n  nodeMuster.push(\r\n    renderNodeMuster(\"norm\", \"\", \"muster-path muster-not-active\", \"path\")\r\n  );\r\n  nodeMuster.push(\r\n    renderNodeMuster(\"norm\", \"\", \"muster-algo muster-not-active\", \"algo\")\r\n  );\r\n  nodeMuster.push(\r\n    renderNodeMuster(\"norm\", \"\", \"muster-norm muster-not-active\", \"norm\")\r\n  );\r\n  return nodeMuster;\r\n};\r\n\r\nclass NodeMuster extends PureComponent {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      type: props.type,\r\n      locator: props.locator,\r\n      classAs: props.classAs,\r\n      idAs: props.idAs,\r\n    };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className={\"muster-node-wrapper\"}>\r\n        <button\r\n          // Class/id properties\r\n          className={\r\n            \"muster-node \" + this.state.type + \" \" + this.state.classAs\r\n          }\r\n          id={\"muster-\" + this.state.idAs}\r\n        >\r\n          {setImgLocator(this.state.locator)}\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction setImgLocator(loc) {\r\n  var cls = \"loc\";\r\n  if (loc === \"start\")\r\n    return (\r\n      <div className={\"rel \" + cls}>\r\n        <img className=\"bg\" src={bgSVG} draggable=\"false\" alt=\"Start node BG\" />\r\n        <img\r\n          className=\"img st\"\r\n          src={startSVG}\r\n          draggable=\"false\"\r\n          alt=\"Start node\"\r\n        />\r\n      </div>\r\n    );\r\n  if (loc === \"end\")\r\n    return (\r\n      <div className={\"rel \" + cls}>\r\n        <img\r\n          className=\"bg\"\r\n          src={bgSVG}\r\n          draggable=\"false\"\r\n          alt=\"Target node BG\"\r\n        />\r\n        <img\r\n          className=\"img en\"\r\n          src={endSVG}\r\n          draggable=\"false\"\r\n          alt=\"Target node\"\r\n        />\r\n      </div>\r\n    );\r\n  if (loc === \"weight\")\r\n    return (\r\n      <div className={\"rel loc\"}>\r\n        <img\r\n          className=\"hand\"\r\n          src={weightSVG}\r\n          draggable=\"false\"\r\n          alt=\"Weight node BG\"\r\n        />\r\n      </div>\r\n    );\r\n}\r\n","import React from \"react\";\r\n\r\nexport const algoText = (algoType) => {\r\n  if (algoType === \"dijkstra\") return dijkstraText();\r\n  else if (algoType === \"astar\") return astarText();\r\n  else if (algoType === \"bestfs\") return bestfsText();\r\n  else if (algoType === \"breadthfs\") return breadthfsText();\r\n  else if (algoType === \"depthfs\") return depthfsText();\r\n};\r\n\r\nfunction dijkstraText() {\r\n  var text = { name: null, desc: null };\r\n  text.name = \"DIJKSTRA'S\";\r\n  text.desc =\r\n    \"This algorithm guarantees shortest path. It can be weighted or unweighted (takes edge costs into account). No heuristic (distance measure) is used.\";\r\n  return text;\r\n}\r\n\r\nfunction astarText() {\r\n  var text = { name: null, desc: null };\r\n  text.name = \"A* (A-STAR)\";\r\n  text.desc =\r\n    \"This algorithm guarantees shortest path. It can be weighted or unweighted (takes edge costs into account). Uses heuristic (distance measure). Maximum effectivity for pathfinding.\";\r\n  return text;\r\n}\r\n\r\nfunction bestfsText() {\r\n  var text = { name: null, desc: null };\r\n  text.name = \"BEST FIRST SEARCH\";\r\n  text.desc =\r\n    \"This algorithm guarantees shortest path. It can be only unweighted (doesn't take edge costs into account). Uses heuristic (distance measure).\";\r\n  return text;\r\n}\r\n\r\nfunction breadthfsText() {\r\n  var text = { name: null, desc: null };\r\n  text.name = \"BREADTH FIRST SEARCH\";\r\n  text.desc =\r\n    \"This algorithm guarantees shortest path. It can be only unweighted (doesn't take edge costs into account). No heuristic (distance measure) is used.\";\r\n  return text;\r\n}\r\n\r\nfunction depthfsText() {\r\n  var text = { name: null, desc: null };\r\n  text.name = \"DEPTH FIRST SEARCH\";\r\n  text.desc =\r\n    \"This algorithm doesn't guarantee shortest path. It can be only unweighted (doesn't take edge costs into account). It is often used e.g. to identify connected nodes in a graph component.\";\r\n  return text;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Navbar from \"react-bootstrap/Navbar\";\r\nimport Nav from \"react-bootstrap/Nav\";\r\nimport NavDropdown from \"react-bootstrap/NavDropdown\";\r\nimport OverlayTrigger from \"react-bootstrap/OverlayTrigger\";\r\nimport Tooltip from \"react-bootstrap/Tooltip\";\r\nimport { makeArrayMuster } from \"./NodeMuster.js\";\r\nimport { algoText } from \"./AlgoText.js\";\r\nimport \"../App.css\";\r\n\r\nexport default class Header extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      clickedAlgo: \"dijkstra\",\r\n    };\r\n  }\r\n\r\n  render() {\r\n    const musters = makeArrayMuster();\r\n    try {\r\n      var text = algoText(this.state.clickedAlgo);\r\n      var weightAv = isWeightAvailable(this.state.clickedAlgo);\r\n    } catch {\r\n      var text = algoText(\"dijkstra\");\r\n      var weightAv = true;\r\n    }\r\n    if (!weightAv) var weighted = \"weight-red\";\r\n\r\n    return (\r\n      <div>\r\n        {/* ----------------------- MENU NAVBAR --------------------- */}\r\n\r\n        <Navbar id=\"custom-bg\" bg=\"\" variant=\"dark\" expand=\"lg\">\r\n          <div className=\"order-0\">\r\n            <Navbar.Text id=\"brand\">\r\n              <span className=\"brand-name\">\r\n                &nbsp;&nbsp;P&nbsp;a&nbsp;t&nbsp;h\r\n              </span>\r\n              &nbsp;&nbsp;V&nbsp;i&nbsp;s&nbsp;u&nbsp;a&nbsp;l&nbsp;i&nbsp;z&nbsp;e&nbsp;r&nbsp;&nbsp;\r\n            </Navbar.Text>\r\n          </div>\r\n\r\n          {/* ++++++++++++ dropdown menu ++++++++++++ */}\r\n\r\n          <Navbar.Toggle\r\n            className=\"mx-auto toggle-nav\"\r\n            aria-controls=\"basic-navbar-nav\"\r\n          />\r\n          <Navbar.Collapse\r\n            id=\"basic-navbar-nav\"\r\n            className=\"mx-auto collapse-nav\"\r\n          >\r\n            <div className=\"mx-auto order-1\">\r\n              <Nav className=\"\">\r\n                <Navbar.Text>\r\n                  {\" \"}\r\n                  &nbsp;&nbsp;/&nbsp;choose&nbsp;/&nbsp;&nbsp;\r\n                </Navbar.Text>\r\n                <NavDropdown\r\n                  className=\"dropdown-title\"\r\n                  id=\"header-link-alg\"\r\n                  title=\"ALGORITHMS\"\r\n                >\r\n                  <div className=\"ddown\">\r\n                    <NavDropdown.Item\r\n                      className=\"dropdown-link\"\r\n                      onClick={() => {\r\n                        this.props.algoSelected(\"dijkstra\");\r\n                        this.setState({ clickedAlgo: \"dijkstra\" }, () => {\r\n                          console.log(\"chosen dijkstra in header...\");\r\n                        });\r\n                      }}\r\n                    >\r\n                      DIJKSTRA'S\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      className=\"dropdown-link\"\r\n                      onClick={() => {\r\n                        this.props.algoSelected(\"astar\");\r\n                        this.setState({ clickedAlgo: \"astar\" }, () => {\r\n                          console.log(\"chosen astar in header...\");\r\n                        });\r\n                      }}\r\n                    >\r\n                      A*\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      className=\"dropdown-link\"\r\n                      onClick={() => {\r\n                        this.props.algoSelected(\"bestfs\");\r\n                        this.setState({ clickedAlgo: \"bestfs\" }, () => {\r\n                          console.log(\"chosen bestfs in header...\");\r\n                        });\r\n                      }}\r\n                    >\r\n                      BEST SEARCH FIRST\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      className=\"dropdown-link\"\r\n                      onClick={() => {\r\n                        this.props.algoSelected(\"breadthfs\");\r\n                        this.setState({ clickedAlgo: \"breadthfs\" }, () => {\r\n                          console.log(\"chosen bredthfs in header...\");\r\n                        });\r\n                      }}\r\n                    >\r\n                      BREADTH SEARCH FIRST\r\n                    </NavDropdown.Item>\r\n                    <NavDropdown.Item\r\n                      className=\"dropdown-link\"\r\n                      onClick={() => {\r\n                        this.props.algoSelected(\"depthfs\");\r\n                        this.setState({ clickedAlgo: \"depthfs\" }, () => {\r\n                          console.log(\"chosen depth in header...\");\r\n                        });\r\n                      }}\r\n                    >\r\n                      DEPTH SEARCH FIRST\r\n                    </NavDropdown.Item>\r\n                  </div>\r\n                </NavDropdown>\r\n\r\n                {/* ++++++++++++ options menu ++++++++++++ */}\r\n\r\n                <Navbar.Text>\r\n                  &nbsp;&nbsp;/&nbsp;generate&nbsp;/&nbsp;&nbsp;\r\n                </Navbar.Text>\r\n\r\n                <div id=\"header-link-maze\">\r\n                  <Nav.Link\r\n                    id=\"header-link\"\r\n                    onClick={() => this.props.generateMaze()}\r\n                  >\r\n                    {\" \"}\r\n                    maze{\" \"}\r\n                  </Nav.Link>\r\n                </div>\r\n                <div id=\"header-link-stairs\">\r\n                  <Nav.Link\r\n                    id=\"header-link\"\r\n                    onClick={() => this.props.generateStairs()}\r\n                  >\r\n                    {\" \"}\r\n                    stairs{\" \"}\r\n                  </Nav.Link>\r\n                </div>\r\n\r\n                <Navbar.Text>\r\n                  &nbsp;&nbsp;/&nbsp;vizualize&nbsp;/&nbsp;&nbsp;\r\n                </Navbar.Text>\r\n                <div id=\"header-link-clear\">\r\n                  <Nav.Link\r\n                    id=\"header-link\"\r\n                    onClick={() => this.props.clearBoard()}\r\n                  >\r\n                    clear\r\n                  </Nav.Link>\r\n                </div>\r\n                <div id=\"header-link-start\">\r\n                  <Nav.Link\r\n                    id=\"header-link-viz\"\r\n                    onClick={() => {\r\n                      this.props.algo();\r\n                    }}\r\n                  >\r\n                    start\r\n                  </Nav.Link>\r\n                </div>\r\n              </Nav>\r\n            </div>\r\n          </Navbar.Collapse>\r\n          <div className=\"order-0\">\r\n            <Nav.Link\r\n              id=\"header-link\"\r\n              href=\"https://github.com/holpet/pathfinder\"\r\n            >\r\n              Github&nbsp;repository\r\n            </Nav.Link>\r\n          </div>\r\n        </Navbar>\r\n\r\n        {/* ----------------------- LEGEND NAVBAR --------------------- */}\r\n\r\n        <Navbar>\r\n          <Nav className=\"mx-auto \">\r\n            <div className=\"muster-nav\">\r\n              <div className=\"muster-noflex\">\r\n                {musters[0]}\r\n                <OverlayTrigger\r\n                  key=\"bottom\"\r\n                  placement=\"bottom\"\r\n                  overlay={\r\n                    <Tooltip id={`tooltip-start`} bsPrefix=\"tooltip-custom\">\r\n                      Move start node with&nbsp;&nbsp;[mouse button].\r\n                    </Tooltip>\r\n                  }\r\n                >\r\n                  <Navbar.Text className=\"bold-text\">\r\n                    &nbsp;&nbsp;START&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                  </Navbar.Text>\r\n                </OverlayTrigger>\r\n              </div>\r\n              <div className=\"muster-noflex\">\r\n                {musters[1]}\r\n                <OverlayTrigger\r\n                  key=\"bottom\"\r\n                  placement=\"bottom\"\r\n                  overlay={\r\n                    <Tooltip id={`tooltip-end`} bsPrefix=\"tooltip-custom\">\r\n                      Move end node with&nbsp;&nbsp;[mouse button].\r\n                    </Tooltip>\r\n                  }\r\n                >\r\n                  <Navbar.Text className=\"bold-text\">\r\n                    &nbsp;&nbsp;END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                  </Navbar.Text>\r\n                </OverlayTrigger>\r\n              </div>\r\n              <div className=\"muster-noflex\">\r\n                {musters[2]}\r\n                <OverlayTrigger\r\n                  key=\"bottom\"\r\n                  placement=\"bottom\"\r\n                  overlay={\r\n                    <Tooltip id={`tooltip-walls`} bsPrefix=\"tooltip-custom\">\r\n                      Draw walls by holding down&nbsp;&nbsp;[mouse button].\r\n                    </Tooltip>\r\n                  }\r\n                >\r\n                  <Navbar.Text className=\"bold-text\">\r\n                    &nbsp;&nbsp;WALL&nbsp;(no&nbsp;pass)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                  </Navbar.Text>\r\n                </OverlayTrigger>\r\n              </div>\r\n              <div className=\"muster-noflex\">\r\n                {musters[3]}\r\n                <OverlayTrigger\r\n                  key=\"bottom\"\r\n                  placement=\"bottom\"\r\n                  overlay={\r\n                    <Tooltip id={`tooltip-weights`} bsPrefix=\"tooltip-custom\">\r\n                      Draw weights by holding\r\n                      down&nbsp;&nbsp;[CTRL]&nbsp;&nbsp;+&nbsp;&nbsp;[mouse\r\n                      button].\r\n                    </Tooltip>\r\n                  }\r\n                >\r\n                  <Navbar.Text className=\"bold-text\">\r\n                    &nbsp;&nbsp;\r\n                    <span className={weighted}>\r\n                      WEIGHT&nbsp;(passing&nbsp;is&nbsp;harder&nbsp;6:1)\r\n                    </span>\r\n                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                  </Navbar.Text>\r\n                </OverlayTrigger>\r\n              </div>\r\n              <div className=\"muster-noflex\">\r\n                {musters[6]}\r\n                <OverlayTrigger\r\n                  key=\"bottom\"\r\n                  placement=\"bottom\"\r\n                  overlay={\r\n                    <Tooltip id={`tooltip-unvisited`} bsPrefix=\"tooltip-custom\">\r\n                      Draw yourself or generate random maze/stairs (above).\r\n                    </Tooltip>\r\n                  }\r\n                >\r\n                  <Navbar.Text className=\"bold-text\">\r\n                    &nbsp;&nbsp;UNVISITED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                  </Navbar.Text>\r\n                </OverlayTrigger>\r\n              </div>\r\n              <div className=\"muster-noflex\">\r\n                {musters[5]}\r\n                <OverlayTrigger\r\n                  key=\"bottom\"\r\n                  placement=\"bottom\"\r\n                  overlay={\r\n                    <Tooltip id={`tooltip-visited`} bsPrefix=\"tooltip-custom\">\r\n                      Solve algorithm by clicking on&nbsp;&nbsp;[start].\r\n                    </Tooltip>\r\n                  }\r\n                >\r\n                  <Navbar.Text className=\"bold-text\">\r\n                    &nbsp;&nbsp;VISITED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n                  </Navbar.Text>\r\n                </OverlayTrigger>\r\n              </div>\r\n              <div className=\"muster-noflex\">\r\n                {musters[4]}\r\n                <OverlayTrigger\r\n                  key=\"bottom\"\r\n                  placement=\"bottom\"\r\n                  overlay={\r\n                    <Tooltip id={`tooltip-path`} bsPrefix=\"tooltip-custom\">\r\n                      After solving, move start/end nodes to recalculate path.\r\n                    </Tooltip>\r\n                  }\r\n                >\r\n                  <Navbar.Text className=\"bold-text\">\r\n                    &nbsp;&nbsp;FINAL&nbsp;PATH\r\n                  </Navbar.Text>\r\n                </OverlayTrigger>\r\n              </div>\r\n            </div>\r\n          </Nav>\r\n        </Navbar>\r\n\r\n        {/* ----------------------- DESCRIPTION / HELP NAVBAR --------------------- */}\r\n\r\n        <Navbar className=\"nav-description\">\r\n          <Nav className=\"mx-auto \">\r\n            <div className=\"muster-nav\">\r\n              <div className=\"muster-noflex\">\r\n                <Navbar.Text className=\"bold-text-bigger\">\r\n                  You are solving with:&nbsp;&nbsp;\r\n                  <span id=\"text-algo\">\r\n                    {text.name}\r\n                  </span>&nbsp;&nbsp;algorithm. {text.desc}\r\n                </Navbar.Text>\r\n              </div>\r\n            </div>\r\n          </Nav>\r\n        </Navbar>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport const isWeightAvailable = (algoType) => {\r\n  if (algoType === \"dijkstra\" || algoType === \"astar\") return true;\r\n  else return false;\r\n};\r\n","import React, { PureComponent } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport \"./Grid.css\";\r\nimport startSVG from \"../../img/start.svg\";\r\nimport endSVG from \"../../img/flag.svg\";\r\nimport bgSVG from \"../../img/dot_full.svg\";\r\nimport weightSVG from \"../../img/hold.svg\";\r\n\r\nexport default class NodeView extends PureComponent {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      // Initial values available for change on user action\r\n      row: props.row,\r\n      col: props.col,\r\n      nodeID: props.nodeID,\r\n      type: props.type, // if 'norm' -> transparent bg, if 'wall' -> dark bg\r\n      locator: props.locator, // if 'start' -> img start, if 'end' -> img end, if 'none' -> no img\r\n      gridView: props.gridView,\r\n      gridUpdate: props.gridUpdate,\r\n      clear: props.clear,\r\n      generated: false,\r\n      isWall: props.isWall,\r\n      weighted: props.weighted,\r\n\r\n      // Function to handle all mouse events\r\n      mouseEvents: props.mouseEvents,\r\n      noHover: false,\r\n    };\r\n  }\r\n\r\n  UNSAFE_componentWillReceiveProps(nextProps) {\r\n    if (nextProps.clear !== this.props.clear) {\r\n      this.setState({ clear: nextProps.clear }, function () {\r\n        this.clearNodeView();\r\n      });\r\n    }\r\n    if (nextProps.generated !== this.props.generated) {\r\n      if (\r\n        this.state.isWall(this.state.row, this.state.col) &&\r\n        this.state.locator === \"\"\r\n      ) {\r\n        this.setState({ locator: \"wall\" }, () => {\r\n          this.setState({ generated: false });\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  clearNodeView = () => {\r\n    if (\r\n      (this.state.locator === \"wall\" ||\r\n        this.state.locator === \"weight\" ||\r\n        this.state.locator === \"path\" ||\r\n        this.state.locator === \"algo\") &&\r\n      this.state.clear\r\n    ) {\r\n      this.setState({ locator: \"\" });\r\n      this.setState({ clear: false });\r\n    }\r\n  };\r\n\r\n  handleUserChanges = (event) =>\r\n    this.props.mouseEvents(\r\n      event,\r\n      this,\r\n      this.state.gridView,\r\n      this.state.gridUpdate,\r\n      this.state.weighted\r\n    );\r\n\r\n  render() {\r\n    this.props.gridView.setDict(this);\r\n    var cls = setHover(this.state.locator, this.state.noHover);\r\n    return (\r\n      <div className={\"node-wrapper\"}>\r\n        <button\r\n          // Class/id properties\r\n          className={\"node \" + this.state.type + \" \" + cls}\r\n          id={\"node-\" + this.state.row + \"-\" + this.state.col}\r\n          // Mouse events handlers:\r\n          onMouseUp={this.handleUserChanges}\r\n          onMouseDown={this.handleUserChanges}\r\n          onMouseOver={this.handleUserChanges}\r\n          onMouseEnter={this.handleUserChanges}\r\n          onMouseLeave={this.handleUserChanges}\r\n        >\r\n          {setImgLocator(\r\n            this.state.locator,\r\n            this.state.noHover,\r\n            this.state.row,\r\n            this.state.col\r\n          )}\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nfunction setImgLocator(loc, noHover, row, col) {\r\n  var cls = \"loc\";\r\n  if (noHover) {\r\n    cls = \"\";\r\n  }\r\n  if (loc === \"start\")\r\n    return (\r\n      <div className={\"rel \" + cls}>\r\n        <img className=\"bg\" src={bgSVG} draggable=\"false\" alt=\"Start node BG\" />\r\n        <img\r\n          className=\"img st\"\r\n          src={startSVG}\r\n          draggable=\"false\"\r\n          alt=\"Start node\"\r\n        />\r\n      </div>\r\n    );\r\n  if (loc === \"end\")\r\n    return (\r\n      <div className={\"rel \" + cls}>\r\n        <img\r\n          className=\"bg\"\r\n          src={bgSVG}\r\n          draggable=\"false\"\r\n          alt=\"Target node BG\"\r\n        />\r\n        <img\r\n          className=\"img en\"\r\n          src={endSVG}\r\n          draggable=\"false\"\r\n          alt=\"Target node\"\r\n        />\r\n      </div>\r\n    );\r\n  if (loc === \"weight\")\r\n    return (\r\n      <div className={\"rel loc\"}>\r\n        <img\r\n          id={\"img-\" + row + \"-\" + col}\r\n          className=\"hand\"\r\n          src={weightSVG}\r\n          draggable=\"false\"\r\n          alt=\"Weight node BG\"\r\n        />\r\n      </div>\r\n    );\r\n}\r\n\r\nfunction setHover(loc, noHover) {\r\n  if (loc === \"wall\" && noHover) {\r\n    return \"wall-no-anim\";\r\n  } else if (loc === \"weight\" && noHover) {\r\n    return \"weight-no-anim\";\r\n  }\r\n  return loc;\r\n}\r\n\r\nNodeView.propTypes = {\r\n  row: PropTypes.number,\r\n  col: PropTypes.number,\r\n  nodeID: PropTypes.number,\r\n  type: PropTypes.string,\r\n  locator: PropTypes.string,\r\n  gridView: PropTypes.object,\r\n  gridUpdate: PropTypes.func,\r\n  mouseEvents: PropTypes.func,\r\n  noHover: PropTypes.bool,\r\n  clear: PropTypes.bool,\r\n};\r\n","export const mouseHandler = (event, node, grid, gridUpdate, weighted) => {\r\n  /* Info about changing the state of objects: */\r\n  // setState used for safely re-rendering objects on change (immutable render)\r\n  // directly mutating state only when there is no need to re-render (e.g. \"mouseIsPressed\" var)\r\n\r\n  /* ------------------ on MOUSE DOWN ------------------ */\r\n  if (event.type === \"mousedown\") {\r\n    grid.state.mouseIsPressed = true;\r\n    // CURRENT...: starting node for the mouse move (relevant until the move finishes with \"mouseup\")\r\n    // -- determines what locator will be added/deleted throughout the mouse move\r\n    grid.state.currentLocator = node.state.locator;\r\n    grid.state.currentType = node.state.type;\r\n    grid.state.currentID = node.state.nodeID;\r\n\r\n    /* ------------------ on MOUSE UP ------------------ */\r\n  }\r\n  if (event.type === \"mouseup\") {\r\n    grid.state.mouseIsPressed = false;\r\n\r\n    // Simulate simple click of the mouse on a node:\r\n    if (grid.state.currentID === node.state.nodeID) {\r\n      var loc = \"wall\";\r\n      if (event.ctrlKey && weighted()) loc = \"weight\";\r\n      // Add wall block locator if user clicked on free space\r\n      if (node.state.locator === \"\") {\r\n        node.setState({ locator: loc });\r\n        gridUpdate(node.state.row, node.state.col, loc);\r\n      }\r\n      // Delete wall block locator if user clicked on a wall block already in place\r\n      if (node.state.locator === loc) {\r\n        node.setState({ locator: \"\" });\r\n        gridUpdate(node.state.row, node.state.col, \"\");\r\n      }\r\n    }\r\n\r\n    /* ------------------ on MOUSE ENTER ------------------ */\r\n  }\r\n  if (event.type === \"mouseenter\") {\r\n    node.setState({ noHover: false });\r\n    if (!grid.state.mouseIsPressed) return;\r\n\r\n    // Keep track of the previous node to this one that we've just entered\r\n    const prevSqID = grid.getFirstItemFromLL();\r\n    var prevSq = grid.state.dict[grid.getFirstItemFromLL()];\r\n    node.setState({ noHover: false }); // always allow for hover functionality until set otherwise (noHover: true)\r\n\r\n    if (\r\n      // ................. MOVE START & TARGET LOCATORS ................. //\r\n      grid.state.currentLocator === \"start\" ||\r\n      grid.state.currentLocator === \"end\"\r\n    ) {\r\n      // If entered node is either start/target: don't allow hover anim and don't delete locator from previous node\r\n      if (node.state.locator !== \"\") node.setState({ noHover: true });\r\n      // If entered node is a FREE space:\r\n      else {\r\n        // Allow anim, add currently held locator in place -> update\r\n        node.setState({ noHover: false, locator: grid.state.currentLocator });\r\n        gridUpdate(node.state.row, node.state.col, grid.state.currentLocator);\r\n        // Delete previous locator (go backwards until you find the last position of the locator in the grid) -> update\r\n        while (prevSq.state.locator !== grid.state.currentLocator) {\r\n          grid.shiftFirstItemFromLL();\r\n          prevSq = grid.state.dict[grid.getFirstItemFromLL()];\r\n        }\r\n        prevSq.setState({ locator: \"\" }, function () {\r\n          if (grid.state.algoDisplayed) {\r\n            /********************************************/\r\n            // ALGORITHM RECALCULATION on mouse move of start/target nodes (wait until last state has been set):\r\n            grid.state.algoRecalculate();\r\n          }\r\n        });\r\n        gridUpdate(prevSq.state.row, prevSq.state.col, \"\");\r\n      }\r\n\r\n      // ................. ADD/DELETE WALL/WEIGHT BLOCKS ................. //\r\n    } else {\r\n      loc = \"wall\";\r\n      if (event.ctrlKey && weighted()) loc = \"weight\";\r\n      /********************************************/\r\n      // ADD BLOCK\r\n      if (\r\n        (node.state.locator === \"\" ||\r\n          node.state.locator === \"wall\" ||\r\n          node.state.locator === \"weight\") &&\r\n        grid.state.currentLocator === \"\"\r\n      ) {\r\n        if (prevSqID === grid.state.currentID) {\r\n          prevSq.setState({ locator: loc });\r\n          gridUpdate(prevSq.state.row, prevSq.state.col, loc);\r\n        }\r\n        node.setState({ locator: loc, noHover: false });\r\n        gridUpdate(node.state.row, node.state.col, loc);\r\n\r\n        /********************************************/\r\n        // DELETE BLOCK\r\n      } else if (\r\n        (node.state.locator === \"wall\" ||\r\n          node.state.locator === \"weight\" ||\r\n          node.state.locator === \"\") &&\r\n        grid.state.currentLocator === loc\r\n      ) {\r\n        if (prevSqID === grid.state.currentID) {\r\n          prevSq.setState({ locator: \"\" });\r\n          gridUpdate(prevSq.state.row, prevSq.state.col, \"\");\r\n        }\r\n        node.setState({ locator: \"\", noHover: true });\r\n        gridUpdate(node.state.row, node.state.col, \"\");\r\n      }\r\n    }\r\n\r\n    /* ------------------ on MOUSE LEAVE ------------------ */\r\n  }\r\n  if (event.type === \"mouseleave\" && grid.state.mouseIsPressed) {\r\n    // Save node's ID in the LL to allow searching past user moves on next \"mouseenter\"\r\n    grid.addItemToLL(node.state.nodeID);\r\n  }\r\n};\r\n","import React, { PureComponent } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport NodeView from \"./NodeView.jsx\";\r\nimport \"./Grid.css\";\r\nimport { mouseHandler } from \"./MouseHandler.jsx\";\r\nimport { LinkedList } from \"mnemonist\";\r\n\r\nexport default class GridView extends PureComponent {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      mouseIsPressed: false, // True on \"mousedown\", changes back to false on \"mouseup\"\r\n      currentLocator: \"\", // Keeps track of state locator on \"mousedown\"\r\n      currentType: \"norm\", // Keeps track of state type on \"mousedown\"\r\n      currentID: 0,\r\n      gridMax: props.gridMax,\r\n      gridUpdate: props.gridUpdate,\r\n      dict: {},\r\n      clear: false,\r\n      algoDisplayed: false,\r\n      algoRecalculate: props.algoRecalculate,\r\n      generated: false,\r\n      isWall: props.isWall,\r\n      weighted: props.weighted,\r\n    };\r\n  }\r\n\r\n  UNSAFE_componentWillReceiveProps(nextProps) {\r\n    if (nextProps.clear !== this.props.clear) {\r\n      this.setState({ clear: nextProps.clear });\r\n    }\r\n    if (nextProps.algoDisplayed !== this.props.algoDisplayed) {\r\n      this.setState({ algoDisplayed: nextProps.algoDisplayed });\r\n    }\r\n    if (nextProps.generated !== this.props.generated) {\r\n      this.setState({ generated: true });\r\n      console.log(\"generated from grid...\");\r\n    }\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.setState({ clear: false });\r\n    this.setState({ generated: false });\r\n  }\r\n\r\n  /* ******************* Methods on the grid ******************* */\r\n  /* Set the grid dictionary -> faster lookup of nodes for handlers */\r\n  //dict = {};\r\n  setDict = (node) => {\r\n    this.state.dict[node.props.nodeID] = node;\r\n  };\r\n  getDict = () => {\r\n    return this.state.dict;\r\n  };\r\n  count = 0;\r\n  setRef = (ref) => {\r\n    /*\r\n    if (ref.state.locator === \"wall\") console.log(ref);\r\n    this.state.dict[this.count] = ref;\r\n    this.count++;*/\r\n  };\r\n  getStartNode = () => {\r\n    for (var key in this.state.dict) {\r\n      var value = this.state.dict[key];\r\n      if (value.state.locator === \"start\") return key;\r\n      if (value.state.locator === \"wall\") return key;\r\n    }\r\n    return;\r\n  };\r\n\r\n  /* Set the grid linkedlist -> track past user moves on the board */\r\n  linkedList = new LinkedList();\r\n  addItemToLL = (id) => {\r\n    // add item at the beginning\r\n    this.linkedList.unshift(id);\r\n  };\r\n  getFirstItemFromLL = () => {\r\n    return this.linkedList.first();\r\n  };\r\n  shiftFirstItemFromLL = () => {\r\n    return this.linkedList.shift();\r\n  };\r\n\r\n  /* *********************************************************** */\r\n  /* ********************* Render functions ******************** */\r\n\r\n  /* Render SQUARE */\r\n  renderNode(i, j, nodeID, st_row, st_col, en_row, en_col) {\r\n    var locatorProp = setLocators(i, j, st_row, st_col, en_row, en_col);\r\n    return (\r\n      <NodeView\r\n        ref={this.setRef}\r\n        key={nodeID} // unique identification for React components (returns undefined if called)\r\n        nodeID={nodeID} // id to use for dict keys (returns defined)\r\n        row={i}\r\n        col={j}\r\n        type=\"norm\"\r\n        locator={locatorProp}\r\n        mouseEvents={mouseHandler}\r\n        gridView={this}\r\n        gridUpdate={this.state.gridUpdate}\r\n        clear={this.state.clear}\r\n        generated={this.state.generated}\r\n        isWall={this.state.isWall}\r\n        weighted={this.state.weighted}\r\n      />\r\n    );\r\n  }\r\n  /* Render GRID (filled with SQUARES) */\r\n  render() {\r\n    const grid = [];\r\n    const [maxCol, maxRow] = getRowCol();\r\n    const [st_row, st_col, en_row, en_col] = getLocators(maxCol, maxRow);\r\n\r\n    this.state.gridMax(maxCol, maxRow, st_row, st_col, en_row, en_col);\r\n    var countNodeID = 0;\r\n\r\n    for (var i = 0; i < maxCol; i++) {\r\n      const nodeRows = [];\r\n      for (var j = 0; j < maxRow; j++) {\r\n        // render node\r\n        nodeRows.push(\r\n          this.renderNode(j, i, countNodeID, st_row, st_col, en_row, en_col)\r\n        );\r\n        countNodeID++;\r\n      }\r\n      grid.push(<div key={i}>{nodeRows}</div>);\r\n    }\r\n    this.ctn = 0;\r\n    return <div className=\"grid\">{grid}</div>;\r\n  }\r\n}\r\n\r\n/* *********************************************************** */\r\n/* ******************** Helper functions ********************* */\r\n\r\n// Calculate how many nodes in a row & col (based on viewport size)\r\nfunction getRowCol() {\r\n  var nodeSize = 35; // Max w/h of accurately visible nodes - for FULL HD res\r\n  /*\r\n  if (window.screen.width < 576) nodeSize = 25;\r\n  if (window.screen.width < 768) nodeSize = 28;\r\n  if (window.screen.width < 1200) nodeSize = 31;*/\r\n\r\n  var num_i = Math.floor(window.screen.width / nodeSize) - 1;\r\n  var num_j = Math.floor(\r\n    (window.screen.height - (window.screen.height / 100) * 35) / nodeSize\r\n  );\r\n  //if (num_i % 2 !== 0) num_i++;\r\n  if (num_j % 2 !== 1) num_j++;\r\n  console.log(\"i \" + num_i + \" j \" + num_j);\r\n  return [num_i, num_j];\r\n}\r\n\r\n// Decide where to place locators on the grid\r\nfunction getLocators(maxCol, maxRow) {\r\n  const st_row = Math.floor(maxRow / 2) - 1;\r\n  const st_col = Math.floor(maxCol / 3);\r\n  const en_row = Math.floor(maxRow / 2) - 1;\r\n  const en_col = Math.floor((maxCol / 3) * 2);\r\n  // console.log(\r\n  //   \"start+end r/c: \" + st_row + \" \" + st_col + \" .. \" + en_row + \" \" + en_col\r\n  // );\r\n  return [st_row, st_col, en_row, en_col];\r\n}\r\n\r\n// Place locators on the grid\r\nfunction setLocators(j, i, start_row, start_col, end_row, end_col) {\r\n  var locatorProp = \"\";\r\n  if (j === start_row && i === start_col) {\r\n    locatorProp = \"start\";\r\n    return locatorProp;\r\n  }\r\n  if (j === end_row && i === end_col) {\r\n    locatorProp = \"end\";\r\n    return locatorProp;\r\n  }\r\n  return locatorProp;\r\n}\r\n\r\nGridView.propTypes = {\r\n  gridMax: PropTypes.func,\r\n  gridUpdate: PropTypes.func,\r\n  clear: PropTypes.bool,\r\n};\r\n","export const createNode = (col, row, locator, nodeID) => {\r\n  return {\r\n    row,\r\n    col,\r\n    locator,\r\n    nodeID,\r\n\r\n    // Vars for algorithms\r\n    distance: Infinity,\r\n    totalDistance: Infinity,\r\n    isVisited: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n","export const stairs = (grid) => {\r\n  const maxRow = grid[0].length;\r\n  const maxCol = grid.length;\r\n\r\n  var mappedAr = [];\r\n  var ctn = 0;\r\n  var i = 0;\r\n  var j = 0;\r\n\r\n  for (i = 0; i < maxRow; i++) {\r\n    ctn++;\r\n    if (checkLocator(grid, i, i)) continue;\r\n    mappedAr.push(grid[i][i]);\r\n    grid[i][i].locator = \"wall\";\r\n  }\r\n  for (i = maxRow - 2, j = ctn; i > 0; i--, j++) {\r\n    ctn++;\r\n    if (checkLocator(grid, j, i)) continue;\r\n    mappedAr.push(grid[j][i]);\r\n    grid[j][i].locator = \"wall\";\r\n  }\r\n\r\n  for (i = 2, j = ctn; j < maxCol - 1; i++, j++) {\r\n    if (checkLocator(grid, j, i)) continue;\r\n    mappedAr.push(grid[j][i]);\r\n    grid[j][i].locator = \"wall\";\r\n  }\r\n\r\n  return [mappedAr, grid];\r\n};\r\n\r\nfunction checkLocator(grid, j, i) {\r\n  return grid[j][i].locator === \"start\" ||\r\n    grid[j][i].locator === \"end\" ||\r\n    grid[j][i].locator === \"wall\" ||\r\n    grid[j][i].locator === \"weight\"\r\n    ? true\r\n    : false;\r\n}\r\n","import { Stack } from \"mnemonist\";\r\n\r\n/* RANDOMIZED BACKTRACKING ALGORITHM (depth first search) */\r\n\r\nexport const randomizedMaze = (grid) => {\r\n  const maxRow = grid[0].length;\r\n  const maxCol = grid.length;\r\n  console.log(\"max row... \" + maxRow + \" max col... \" + maxCol);\r\n\r\n  // Find coordinates of start/end node\r\n  for (var i = 0; i < maxRow; i++) {\r\n    for (var j = 0; j < maxCol; j++) {\r\n      if (grid[j][i].locator === \"start\") {\r\n        var start = grid[j][i];\r\n        console.log(\"start in A* \" + start.row + \" \" + start.col);\r\n      } else if (grid[j][i].locator === \"end\") {\r\n        var end = grid[j][i];\r\n        console.log(\"end in A* \" + end.row + \" \" + end.col);\r\n      }\r\n    }\r\n  }\r\n\r\n  start.isVisited = true;\r\n  end.isVisited = true;\r\n\r\n  var mappedMaze = []; // final maze mapped in order of wall generation\r\n  var stack = new Stack();\r\n\r\n  // fill the edges of the maze:\r\n  //[mappedMaze, grid] = fillEdges(grid, maxCol, maxRow, mappedMaze);\r\n\r\n  // fill the rest of the maze:\r\n  /* pick random start node of algo */\r\n  var check = false;\r\n  while (!check) {\r\n    var randRow = getRandomNum(0, maxRow - 1);\r\n    var randCol = getRandomNum(0, maxCol - 1);\r\n    console.log(\"rand row: \" + randRow + \" , rand col: \" + randCol);\r\n    check = checkLocator(grid, randRow, randCol);\r\n    if (randRow % 2 === 0) check = false;\r\n  }\r\n\r\n  // save starting node\r\n  var start = grid[randCol][randRow];\r\n  console.log(\"random start r/c: \" + start.row + \" \" + start.col);\r\n  start.isVisited = true;\r\n  start.locator = \"wall\";\r\n  stack.push(start);\r\n  mappedMaze.push(start);\r\n\r\n  // START NODE ---> TARGET NODE || Top -> Right -> Bottom -> Left\r\n  const dr = [-2, 0, 2, 0];\r\n  const dc = [0, 2, 0, -2];\r\n\r\n  while (stack.size > 0) {\r\n    var current = stack.pop();\r\n    var availableNeighbours = [];\r\n    console.log(\"current r/c: \" + current.row + \" \" + current.col);\r\n\r\n    // Check all 4 neighbours around the node\r\n    for (var i = 0; i < 4; i++) {\r\n      const row = current.row + dr[i];\r\n      const col = current.col + dc[i];\r\n\r\n      if (!isValidOnBoard(row, col, maxRow, maxCol)) continue;\r\n\r\n      var neighbour = grid[col][row];\r\n      if (!neighbour.isVisited && neighbour.locator === \"\") {\r\n        stack.push(current);\r\n        availableNeighbours.push(neighbour);\r\n      }\r\n    }\r\n\r\n    if (availableNeighbours.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    // choose neighbour of the current node\r\n    var randomNum = getRandomNum(0, availableNeighbours.length - 1);\r\n    var nextNode = availableNeighbours[randomNum];\r\n    nextNode.isVisited = true;\r\n    nextNode.locator = \"wall\";\r\n    stack.push(nextNode);\r\n    mappedMaze.push(nextNode);\r\n    console.log(\"neighbour r/c: \" + nextNode.row + \" \" + nextNode.col);\r\n\r\n    // connect neighbour and the current node\r\n    var joiningNode = null;\r\n    // bottom\r\n    if (nextNode.col > current.col && nextNode.row === current.row) {\r\n      joiningNode = grid[current.col + 1][current.row];\r\n      console.log(\"bottom... nextNode.col > current.col\");\r\n    }\r\n    // top\r\n    else if (nextNode.col < current.col && nextNode.row === current.row) {\r\n      joiningNode = grid[current.col - 1][current.row];\r\n      console.log(\"top... nextNode.col < current.col\");\r\n    }\r\n    // left\r\n    else if (nextNode.row < current.row && nextNode.col === current.col) {\r\n      joiningNode = grid[current.col][current.row - 1];\r\n      console.log(\"left... nextNode.row < current.row\");\r\n    }\r\n    // right\r\n    else if (nextNode.row > current.row && nextNode.col === current.col) {\r\n      joiningNode = grid[current.col][current.row + 1];\r\n      console.log(\"right... nextNode.row > current.row\");\r\n    }\r\n    console.log(\"joining node: \" + joiningNode.row + \" \" + joiningNode.col);\r\n\r\n    if (joiningNode.locator === \"start\" || joiningNode.locator === \"end\")\r\n      continue;\r\n\r\n    joiningNode.isVisited = true;\r\n    joiningNode.locator = \"wall\";\r\n    mappedMaze.push(joiningNode);\r\n  }\r\n\r\n  return [mappedMaze, grid];\r\n};\r\n\r\n// Validate if next neighbour is being checked on board and not outside\r\nfunction isValidOnBoard(row, col, maxRow, maxCol) {\r\n  return row < maxRow && row >= 0 && col < maxCol && col >= 0 ? true : false;\r\n}\r\n\r\nfunction getRandomNum(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nfunction checkLocator(grid, col, row) {\r\n  return grid[row][col].locator === \"start\" || grid[row][col].locator === \"end\"\r\n    ? false\r\n    : true;\r\n}\r\n\r\nfunction fillEdges(grid, maxRow, maxCol, mappedMaze) {\r\n  // TOP\r\n  for (var i = 0; i < maxCol; i++) {\r\n    if (!checkLocator(grid, i, 0)) continue;\r\n    mappedMaze.push(grid[i][0]);\r\n    grid[i][0].locator = \"wall\";\r\n  }\r\n  // RIGHT\r\n  for (i = 1; i < maxRow; i++) {\r\n    if (!checkLocator(grid, maxCol - 1, i)) continue;\r\n    mappedMaze.push(grid[maxCol - 1][i]);\r\n    grid[maxCol - 1][i].locator = \"wall\";\r\n  }\r\n  // BOTTOM\r\n  for (i = maxCol - 2; i >= 0; i--) {\r\n    if (!checkLocator(grid, i, maxRow - 1)) continue;\r\n    mappedMaze.push(grid[i][maxRow - 1]);\r\n    grid[i][maxRow - 1].locator = \"wall\";\r\n  }\r\n  // LEFT\r\n  for (i = maxRow - 2; i > 0; i--) {\r\n    if (!checkLocator(grid, 0, i)) continue;\r\n    mappedMaze.push(grid[0][i]);\r\n    grid[0][i].locator = \"wall\";\r\n  }\r\n  return [mappedMaze, grid];\r\n}\r\n","import { Queue } from \"mnemonist\";\r\n\r\n// BREADTH FIRST SEARCH ALGORITHM\r\n/* Finds shortest path in a graph, non-weighted. */\r\n\r\nexport const breadthFS = (grid) => {\r\n  // Calculate total number of nodes\r\n  const maxRow = grid[0].length;\r\n  const maxCol = grid.length;\r\n  var start = null;\r\n  var end = null;\r\n\r\n  // Find coordinates of start/end node\r\n  for (var i = 0; i < maxRow; i++) {\r\n    for (var j = 0; j < maxCol; j++) {\r\n      if (grid[j][i].locator === \"start\") {\r\n        start = grid[j][i];\r\n        console.log(\"start in BFS \" + start.row + \" \" + start.col);\r\n      } else if (grid[j][i].locator === \"end\") {\r\n        end = grid[j][i];\r\n        console.log(\"end in BFS \" + end.row + \" \" + end.col);\r\n      }\r\n    }\r\n  }\r\n\r\n  // SOLVE BFS\r\n  const solveBFS = (grid, start) => {\r\n    // Make a queue for adding adjacent nodes on the grid (from \"start\")\r\n    var Q = new Queue();\r\n    Q.enqueue(start);\r\n    // Set previous node to itself and isVisited\r\n    start.previousNode = start;\r\n    start.isVisited = true;\r\n    // Keep track of the order of nodes that get visited\r\n    var mapped = [];\r\n    mapped.push(start);\r\n\r\n    // START NODE ---> TARGET NODE || Top -> Right -> Bottom -> Left\r\n    const dr = [-1, 0, 1, 0];\r\n    const dc = [0, 1, 0, -1];\r\n\r\n    while (Q.size > 0) {\r\n      // Get first elements from the queue\r\n      var node = Q.dequeue();\r\n\r\n      // Check all 4 neighbours around the node\r\n      for (var i = 0; i < 4; i++) {\r\n        const row = node.row + dr[i];\r\n        const col = node.col + dc[i];\r\n\r\n        if (isValidOnBoard(row, col, maxRow, maxCol)) {\r\n          var neighbour = grid[col][row];\r\n          if (\r\n            !neighbour.isVisited &&\r\n            (neighbour.locator === \"\" || neighbour.locator === \"end\")\r\n          ) {\r\n            Q.enqueue(neighbour);\r\n            neighbour.isVisited = true;\r\n            neighbour.previousNode = node;\r\n            mapped.push(neighbour);\r\n          }\r\n\r\n          // Finish search when the end node is found and return the mapped area\r\n          if (neighbour.locator === \"end\") {\r\n            console.log(\r\n              \"THE END FOUND. \" + neighbour.row + \" \" + neighbour.col\r\n            );\r\n            return { mappedSearch: mapped, foundEnd: true };\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /* ------------- END OF WHILE LOOP ------------- */\r\n    console.log(\"THE END WASN'T FOUND. No path available.\");\r\n    return { mappedSearch: mapped, foundEnd: false };\r\n  };\r\n\r\n  const reconstructPath = (mappedFunction, start, end) => {\r\n    const mapped = mappedFunction.mappedSearch;\r\n    const foundEnd = mappedFunction.foundEnd;\r\n    var pathMapped = [];\r\n\r\n    if (!foundEnd) {\r\n      pathMapped.push(start);\r\n      pathMapped.push(end);\r\n      return pathMapped;\r\n    }\r\n\r\n    // Traverse through the mapped array backwards to reconstruct path from end to start\r\n    var node = mapped[mapped.length - 1];\r\n    pathMapped.push(node);\r\n    while (node.locator !== \"start\") {\r\n      node = node.previousNode;\r\n      pathMapped.push(node);\r\n    }\r\n    console.log(\"Final path length: \" + pathMapped.length);\r\n    pathMapped.reverse();\r\n    return pathMapped;\r\n  };\r\n\r\n  const mappedFunction = solveBFS(grid, start);\r\n  const finalPath = reconstructPath(mappedFunction, start, end);\r\n\r\n  return { mappedFunction: mappedFunction.mappedSearch, finalPath: finalPath };\r\n};\r\n\r\n// Validate if next neighbour is being check on board and not outside\r\nfunction isValidOnBoard(row, col, maxRow, maxCol) {\r\n  return row < maxRow && row >= 0 && col < maxCol && col >= 0 ? true : false;\r\n}\r\n","import { Heap } from \"mnemonist\";\r\n\r\n// DIJKSTRA SEARCH ALGORITHM (non-lazy)\r\n/* Finds shortest path in a graph, weighted. Cannot contain negative edges to prevent wrong output and infinite loops.\r\n--- takes into account ONLY edge costs (cost from start to node), not heuristic values (distance from node to end) */\r\n\r\nexport const dijkstra = (grid) => {\r\n  const maxRow = grid[0].length; // 13?\r\n  const maxCol = grid.length; // 75?\r\n  var start = null;\r\n  var end = null;\r\n\r\n  // Find coordinates of start/end node\r\n  for (var i = 0; i < maxRow; i++) {\r\n    for (var j = 0; j < maxCol; j++) {\r\n      if (grid[j][i].locator === \"start\") {\r\n        start = grid[j][i];\r\n      } else if (grid[j][i].locator === \"end\") {\r\n        end = grid[j][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  // SOLVE DIJKSTRA\r\n  const solveDijkstra = (grid, start) => {\r\n    // Make a priority queue for adjacent nodes on the grid (from \"start\")\r\n    // max priority = node with shortest distance\r\n    var PQ = new Heap(function (obj1, obj2) {\r\n      if (obj1.distance < obj2.distance) return -1;\r\n      if (obj1.distance > obj2.distance) return 1;\r\n      return 0;\r\n    });\r\n    // Set previous node to itself, isVisited and distance to 0\r\n    start.previousNode = start;\r\n    start.isVisited = true;\r\n    start.distance = 0;\r\n    PQ.push({ distance: start.distance, node: start });\r\n    // Keep track of the order of nodes that get visited\r\n    var mapped = [];\r\n    mapped.push(start);\r\n\r\n    // START NODE ---> TARGET NODE || Top -> Right -> Bottom -> Left\r\n    const dr = [-1, 0, 1, 0];\r\n    const dc = [0, 1, 0, -1];\r\n    var distCounter = 0; // for adding cumulative distance to nodes\r\n\r\n    while (PQ.size > 0) {\r\n      // Get the top element from the heap\r\n      var node = PQ.pop().node;\r\n      distCounter++;\r\n\r\n      // Check all 4 neighbours around the node\r\n      for (var i = 0; i < 4; i++) {\r\n        const row = node.row + dr[i];\r\n        const col = node.col + dc[i];\r\n\r\n        if (isValidOnBoard(row, col, maxRow, maxCol)) {\r\n          var neighbour = grid[col][row];\r\n          if (\r\n            !neighbour.isVisited &&\r\n            (neighbour.locator === \"\" ||\r\n              neighbour.locator === \"end\" ||\r\n              neighbour.locator === \"weight\")\r\n          ) {\r\n            // Add distance with or without weight\r\n            if (neighbour.locator === \"weight\") {\r\n              neighbour.distance = distCounter + 6; // WEIGHT: (+3) low, (+6) average, (+9) high\r\n            } else neighbour.distance = distCounter; // WEIGHT: (1) distance without weight\r\n            // Set neighbour algo props\r\n            neighbour.isVisited = true;\r\n            neighbour.previousNode = node;\r\n            PQ.push({ distance: neighbour.distance, node: neighbour });\r\n            mapped.push(neighbour);\r\n          }\r\n\r\n          // Finish search when the end node is found and return the mapped area\r\n          if (neighbour.locator === \"end\") {\r\n            return { mappedSearch: mapped, foundEnd: true };\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /* ------------- END OF WHILE LOOP ------------- */\r\n    return { mappedSearch: mapped, foundEnd: false };\r\n  };\r\n\r\n  const reconstructPath = (mappedFunction, start, end) => {\r\n    const mapped = mappedFunction.mappedSearch;\r\n    const foundEnd = mappedFunction.foundEnd;\r\n    var pathMapped = [];\r\n\r\n    if (!foundEnd) {\r\n      pathMapped.push(start);\r\n      pathMapped.push(end);\r\n      return pathMapped;\r\n    }\r\n\r\n    // Traverse through the mapped array backwards to reconstruct path from end to start\r\n    var node = mapped[mapped.length - 1];\r\n    pathMapped.push(node);\r\n    while (node.locator !== \"start\") {\r\n      node = node.previousNode;\r\n      pathMapped.push(node);\r\n    }\r\n\r\n    pathMapped.reverse();\r\n    return pathMapped;\r\n  };\r\n\r\n  const mappedFunction = solveDijkstra(grid, start);\r\n  const finalPath = reconstructPath(mappedFunction, start, end);\r\n\r\n  return { mappedFunction: mappedFunction.mappedSearch, finalPath: finalPath };\r\n};\r\n\r\n// Validate if next neighbour is being check on board and not outside\r\nfunction isValidOnBoard(row, col, maxRow, maxCol) {\r\n  return row < maxRow && row >= 0 && col < maxCol && col >= 0 ? true : false;\r\n}\r\n","// DEPTH FIRST SEARCH ALGORITHM\r\n/* Used to find components (connected nodes) in a graph, NOT for shortest path - needs findComponent() */\r\n\r\nexport const depthFS = (grid) => {\r\n  // Calculate total number of nodes\r\n  const maxRow = grid[0].length; // 13?\r\n  const maxCol = grid.length; // 75?\r\n  var start = null;\r\n  var end = null;\r\n\r\n  // Find coordinates of start/end node\r\n  for (var i = 0; i < maxRow; i++) {\r\n    for (var j = 0; j < maxCol; j++) {\r\n      if (grid[j][i].locator === \"start\") {\r\n        start = grid[j][i];\r\n      } else if (grid[j][i].locator === \"end\") {\r\n        end = grid[j][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create an adjacency list for the full grid\r\n  const adjacencyDFS = (grid, maxRow, maxCol) => {\r\n    // Make an obj for adjacent nodes on the grid (from \"start\")\r\n    var AL = {};\r\n    // START NODE ---> TARGET NODE || Top -> Right -> Bottom -> Left\r\n    const dr = [-1, 0, 1, 0];\r\n    const dc = [0, 1, 0, -1];\r\n\r\n    for (var i = 0; i < maxRow; i++) {\r\n      for (var j = 0; j < maxCol; j++) {\r\n        // Prepare an object to add into AL\r\n        var obj = { orig: null, adj: [] };\r\n        var node = grid[j][i];\r\n        obj.orig = node;\r\n\r\n        // Check all 4 neighbours around the node\r\n        for (var k = 0; k < 4; k++) {\r\n          const row = node.row + dr[k];\r\n          const col = node.col + dc[k];\r\n\r\n          if (isValidOnBoard(row, col, maxRow, maxCol)) {\r\n            var neighbour = grid[col][row];\r\n            if (neighbour.locator === \"\" || neighbour.locator === \"end\") {\r\n              obj.adj.push(neighbour);\r\n            }\r\n          }\r\n        }\r\n        AL[node.row + \"-\" + node.col] = obj;\r\n      }\r\n    }\r\n    return AL;\r\n  };\r\n\r\n  const solveDFS = (node, adjList) => {\r\n    // Recurse through nodes in one direction (depth) -> my starting direction is >TOP<, but can be anything\r\n    // If not possible (no available nodes || node isVisited already), backtrack to the last node with next available node and keep going until you find end\r\n\r\n    if (node.isVisited || mapSearch.foundEnd) {\r\n      return;\r\n    }\r\n    if (node.locator === \"end\") {\r\n      mapSearch.foundEnd = true;\r\n      node.isVisited = true;\r\n      mapSearch.mapped.push(node);\r\n      //finalPath.push(node);\r\n      return;\r\n    }\r\n    node.isVisited = true;\r\n    mapSearch.mapped.push(node);\r\n    //finalPath.push(node);\r\n\r\n    const neighbourList = adjList[node.row + \"-\" + node.col].adj;\r\n    for (var i = 0; i < neighbourList.length; i++) {\r\n      solveDFS(neighbourList[i], adjList);\r\n      neighbourList[i].previousNode = node;\r\n    }\r\n  };\r\n\r\n  const reconstructPath = (mappedFunction, start, end) => {\r\n    const foundEnd = mappedFunction.foundEnd;\r\n    var pathMapped = [];\r\n\r\n    if (!foundEnd) {\r\n      pathMapped.push(start);\r\n      pathMapped.push(end);\r\n      return pathMapped;\r\n    }\r\n\r\n    // Traverse through the mapped array backwards to reconstruct path from end to start\r\n    var node = end;\r\n    pathMapped.push(node);\r\n\r\n    while (node.locator !== \"start\") {\r\n      node = node.previousNode;\r\n      pathMapped.push(node);\r\n    }\r\n    pathMapped.reverse();\r\n    return pathMapped;\r\n  };\r\n\r\n  // Keep track of the order of nodes that get visited (global var)\r\n  var mapSearch = { mapped: [], foundEnd: false };\r\n  var finalPath = [];\r\n\r\n  const adjList = adjacencyDFS(grid, maxRow, maxCol);\r\n  solveDFS(start, adjList);\r\n  finalPath = reconstructPath(mapSearch, start, end);\r\n\r\n  return { mappedFunction: mapSearch.mapped, finalPath: finalPath };\r\n};\r\n\r\n// Validate if next neighbour is being check on board and not outside\r\nfunction isValidOnBoard(row, col, maxRow, maxCol) {\r\n  return row < maxRow && row >= 0 && col < maxCol && col >= 0 ? true : false;\r\n}\r\n","import { Heap } from \"mnemonist\";\r\n\r\n// A* ALGORITHM\r\n/* Finds shortest path in a graph, weighted. More effective of pathfinding algorithms\r\n--- takes into account both heuristic values (distance from node to end) + edge costs (cost from start to node) */\r\n\r\nexport const Astar = (grid) => {\r\n  const maxRow = grid[0].length; // 13?\r\n  const maxCol = grid.length; // 75?\r\n  var start = null;\r\n  var end = null;\r\n\r\n  // Find coordinates of start/end node\r\n  for (var i = 0; i < maxRow; i++) {\r\n    for (var j = 0; j < maxCol; j++) {\r\n      if (grid[j][i].locator === \"start\") {\r\n        start = grid[j][i];\r\n      } else if (grid[j][i].locator === \"end\") {\r\n        end = grid[j][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  // SOLVE A*\r\n  const solveAstar = (grid, start) => {\r\n    // Make a priority queue for adjacent nodes on the grid (from \"start\")\r\n    // max priority = node with shortest distance (including heuristic)\r\n    var PQ = new Heap(function (obj1, obj2) {\r\n      if (obj1.distance < obj2.distance) return -1;\r\n      if (obj1.distance >= obj2.distance) return 1;\r\n      return 0;\r\n    });\r\n    // Set previous node to itself, isVisited and distance to 0\r\n    start.previousNode = start;\r\n    start.isVisited = true;\r\n    start.distance = 0;\r\n    PQ.push({ distance: start.distance, node: start });\r\n    // Keep track of the order of nodes that get visited\r\n    var mapped = [];\r\n    mapped.push(start);\r\n    var foundE = false;\r\n\r\n    // START NODE ---> TARGET NODE || Top -> Right -> Bottom -> Left\r\n    const dr = [-1, 0, 1, 0];\r\n    const dc = [0, 1, 0, -1];\r\n\r\n    while (PQ.size > 0) {\r\n      // Get the top element from the heap\r\n      var node = PQ.pop().node;\r\n      mapped.push(node);\r\n\r\n      // Check all 4 neighbours around the node\r\n      for (var i = 0; i < 4; i++) {\r\n        const row = node.row + dr[i];\r\n        const col = node.col + dc[i];\r\n\r\n        if (isValidOnBoard(row, col, maxRow, maxCol)) {\r\n          var neighbour = grid[col][row];\r\n          if (neighbour.locator !== \"wall\") {\r\n            // Check local distance\r\n            var neighbourDistance = neighbour.distance;\r\n            var currentDistance = Infinity;\r\n            if (neighbour.locator === \"weight\") {\r\n              currentDistance = node.distance + 1 + 6;\r\n            } else currentDistance = node.distance + 1;\r\n\r\n            // Add current distance to neighbour if it is smaller\r\n            if (currentDistance < neighbourDistance) {\r\n              neighbour.distance = currentDistance;\r\n              // Else no need to update, go check another neighbour\r\n            } else continue;\r\n\r\n            // Add total (global) distance\r\n            neighbour.totalDistance =\r\n              heuristic(neighbour, end) + neighbour.distance;\r\n            //console.log(\"d: \" + neighbour.distance + \" total d: \" + neighbour.tot)\r\n\r\n            // Set neighbour algo props\r\n            neighbour.isVisited = true;\r\n            neighbour.previousNode = node;\r\n            PQ.push({ distance: neighbour.totalDistance, node: neighbour });\r\n            //mapped.push(neighbour);\r\n          }\r\n\r\n          // Finish search when the end node is found and return the mapped area\r\n\r\n          if (neighbour.locator === \"end\") {\r\n            //mapped.push(neighbour);\r\n            foundE = true;\r\n            return { mappedSearch: mapped, foundEnd: foundE };\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /* ------------- END OF WHILE LOOP ------------- */\r\n\r\n    return { mappedSearch: mapped, foundEnd: foundE };\r\n  };\r\n\r\n  const reconstructPath = (mappedFunction, start, end) => {\r\n    const mapped = mappedFunction.mappedSearch;\r\n    const foundEnd = mappedFunction.foundEnd;\r\n    var pathMapped = [];\r\n\r\n    if (!foundEnd) {\r\n      pathMapped.push(start);\r\n      pathMapped.push(end);\r\n      return pathMapped;\r\n    }\r\n\r\n    // Traverse through the mapped array backwards to reconstruct path from end to start\r\n    var node = end;\r\n    pathMapped.push(node);\r\n    while (node.locator !== \"start\") {\r\n      node = node.previousNode;\r\n      pathMapped.push(node);\r\n    }\r\n    pathMapped.reverse();\r\n    return pathMapped;\r\n  };\r\n\r\n  const mappedFunction = solveAstar(grid, start);\r\n  const finalPath = reconstructPath(mappedFunction, start, end);\r\n\r\n  return { mappedFunction: mappedFunction.mappedSearch, finalPath: finalPath };\r\n};\r\n\r\n// Validate if next neighbour is being check on board and not outside\r\nfunction isValidOnBoard(row, col, maxRow, maxCol) {\r\n  return row < maxRow && row >= 0 && col < maxCol && col >= 0 ? true : false;\r\n}\r\n\r\n// Heuristic calculation\r\nfunction heuristic(node, end) {\r\n  /* Manhattam distance - better for grid implementation (blocks) */\r\n  /* Implements a tie-breaker that makes A* prefer exploring nodes closer to the end */\r\n  /* --- (1.0 + min_step_to_next_node / max_length_of_expected_path) --- */\r\n  return (\r\n    (Math.abs(node.row - end.row) + Math.abs(node.col - end.col)) *\r\n    (1.0 + 1 / 1200)\r\n  );\r\n}\r\n","import { Heap } from \"mnemonist\";\r\n\r\n// BEST FS ALGORITHM\r\n/* Finds shortest path in a graph, non-weighted. \r\n--- takes into account only heuristic values (distance from node to end) */\r\n\r\nexport const bestFS = (grid) => {\r\n  const maxRow = grid[0].length;\r\n  const maxCol = grid.length;\r\n  var start = null;\r\n  var end = null;\r\n\r\n  // Find coordinates of start/end node\r\n  for (var i = 0; i < maxRow; i++) {\r\n    for (var j = 0; j < maxCol; j++) {\r\n      if (grid[j][i].locator === \"start\") {\r\n        start = grid[j][i];\r\n      } else if (grid[j][i].locator === \"end\") {\r\n        end = grid[j][i];\r\n      }\r\n    }\r\n  }\r\n\r\n  // SOLVE BEST FS\r\n  const solveBestFS = (grid, start) => {\r\n    // Make a priority queue for adjacent nodes on the grid (from \"start\")\r\n    // max priority = node with shortest distance (including heuristic)\r\n    var PQ = new Heap(function (obj1, obj2) {\r\n      if (obj1.distance < obj2.distance) return -1;\r\n      if (obj1.distance >= obj2.distance) return 1;\r\n      return 0;\r\n    });\r\n    // Set previous node to itself, isVisited and distance to 0\r\n    start.previousNode = start;\r\n    start.isVisited = true;\r\n    start.distance = 0;\r\n    PQ.push({ distance: start.distance, node: start });\r\n    // Keep track of the order of nodes that get visited\r\n    var mapped = [];\r\n    mapped.push(start);\r\n    var foundE = false;\r\n\r\n    // START NODE ---> TARGET NODE || Top -> Right -> Bottom -> Left\r\n    const dr = [-1, 0, 1, 0];\r\n    const dc = [0, 1, 0, -1];\r\n\r\n    while (PQ.size > 0) {\r\n      // Get the top element from the heap\r\n      var node = PQ.pop().node;\r\n      mapped.push(node);\r\n\r\n      // Check all 4 neighbours around the node\r\n      for (var i = 0; i < 4; i++) {\r\n        const row = node.row + dr[i];\r\n        const col = node.col + dc[i];\r\n\r\n        if (isValidOnBoard(row, col, maxRow, maxCol)) {\r\n          var neighbour = grid[col][row];\r\n          if (neighbour.locator !== \"wall\" && !neighbour.isVisited) {\r\n            // Add distance\r\n            neighbour.distance = heuristic(neighbour, end);\r\n\r\n            // Set neighbour algo props\r\n            neighbour.isVisited = true;\r\n            neighbour.previousNode = node;\r\n            PQ.push({ distance: neighbour.distance, node: neighbour });\r\n            //mapped.push(neighbour);\r\n          }\r\n\r\n          // Finish search when the end node is found and return the mapped area\r\n\r\n          if (neighbour.locator === \"end\") {\r\n            //mapped.push(neighbour);\r\n            foundE = true;\r\n            return { mappedSearch: mapped, foundEnd: foundE };\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /* ------------- END OF WHILE LOOP ------------- */\r\n\r\n    return { mappedSearch: mapped, foundEnd: foundE };\r\n  };\r\n\r\n  const reconstructPath = (mappedFunction, start, end) => {\r\n    const mapped = mappedFunction.mappedSearch;\r\n    const foundEnd = mappedFunction.foundEnd;\r\n    var pathMapped = [];\r\n\r\n    if (!foundEnd) {\r\n      pathMapped.push(start);\r\n      pathMapped.push(end);\r\n      return pathMapped;\r\n    }\r\n\r\n    // Traverse through the mapped array backwards to reconstruct path from end to start\r\n    var node = end;\r\n    pathMapped.push(node);\r\n    while (node.locator !== \"start\") {\r\n      node = node.previousNode;\r\n      pathMapped.push(node);\r\n    }\r\n    pathMapped.reverse();\r\n    return pathMapped;\r\n  };\r\n\r\n  const mappedFunction = solveBestFS(grid, start);\r\n  const finalPath = reconstructPath(mappedFunction, start, end);\r\n\r\n  return { mappedFunction: mappedFunction.mappedSearch, finalPath: finalPath };\r\n};\r\n\r\n// Validate if next neighbour is being check on board and not outside\r\nfunction isValidOnBoard(row, col, maxRow, maxCol) {\r\n  return row < maxRow && row >= 0 && col < maxCol && col >= 0 ? true : false;\r\n}\r\n\r\n// Heuristic calculation\r\nfunction heuristic(node, end) {\r\n  /* Manhattam distance - better for grid implementation (blocks) */\r\n  /* Implements a tie-breaker that makes A* prefer exploring nodes closer to the end */\r\n  /* --- (1.0 + min_step_to_next_node / max_length_of_expected_path) --- */\r\n  return (\r\n    (Math.abs(node.row - end.row) + Math.abs(node.col - end.col)) *\r\n    (1.0 + 1 / 1200)\r\n  );\r\n}\r\n","export const animateSearch = (mappedSearch) => {\r\n  // mappedSearch: array of all visited nodes in order\r\n  // animate without start & end nodes\r\n  clearClasses();\r\n  for (let i = 1; i < mappedSearch.length; i++) {\r\n    if (mappedSearch[i].locator === \"end\") {\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      const node = mappedSearch[i];\r\n      document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        \"node algo\";\r\n    }, 20 * i);\r\n  }\r\n};\r\n\r\nexport const animatePath = (finalPath, mappedSearch) => {\r\n  // finalPath: array of nodes from start to target node representing the shortest path\r\n  // mappedSearch: to determine num of elements that are being animated\r\n  // animate without start & end nodes\r\n  const mappedLength = mappedSearch.length;\r\n  for (let i = 0; i < finalPath.length; i++) {\r\n    setTimeout(() => {\r\n      const node = finalPath[i];\r\n      if (node.locator === \"weight\") {\r\n        document.getElementById(`img-${node.row}-${node.col}`).className =\r\n          \"hand-path\";\r\n      }\r\n      document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        \"node path\";\r\n    }, 20 * (i + mappedLength + 40));\r\n  }\r\n};\r\n\r\nexport const recalcAlgo = (finalPath, mappedSearch) => {\r\n  // final state without animation\r\n  clearClasses();\r\n  for (let i = 1; i < mappedSearch.length - 1; i++) {\r\n    const node = mappedSearch[i];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node algo\";\r\n  }\r\n  for (let i = 0; i < finalPath.length; i++) {\r\n    const node = finalPath[i];\r\n    if (node.locator === \"weight\") {\r\n      document.getElementById(`img-${node.row}-${node.col}`).className =\r\n        \"hand-path\";\r\n    }\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node path\";\r\n  }\r\n};\r\n\r\nexport const animateGenerated = (mappedWalls) => {\r\n  notActive([], mappedWalls);\r\n  for (let i = 0; i < mappedWalls.length; i++) {\r\n    setTimeout(() => {\r\n      const node = mappedWalls[i];\r\n      document\r\n        .getElementById(`node-${node.row}-${node.col}`)\r\n        .classList.add(\"wall-gener\");\r\n    }, 20 * i);\r\n  }\r\n};\r\n\r\nexport const deanimateGeneratedAfter = () => {\r\n  const animWallList = document.getElementsByClassName(`wall-gener`);\r\n  for (let i = 0; i < animWallList.length; i++) {\r\n    animWallList[i].classList.remove(\"wall-gener\");\r\n  }\r\n};\r\n\r\nexport const isWeightOnGrid = (grid, maxRow, maxCol) => {\r\n  for (var i = 0; i < maxRow; i++) {\r\n    for (var j = 0; j < maxCol; j++) {\r\n      if (grid[j][i].locator === \"weight\") {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nfunction clearClasses() {\r\n  var handEl = document.getElementsByClassName(`hand-path`);\r\n  for (var i = 0; i < handEl.length; i++) {\r\n    handEl[i].className = \"hand\";\r\n  }\r\n}\r\n\r\nexport const notActive = (finalPath, mappedSearch) => {\r\n  // finalPath: to determine num of elements that are being animated\r\n  // mappedSearch: to determine num of elements that are being animated\r\n  const mappedLength = mappedSearch.length;\r\n  const finalPathLength = finalPath.length;\r\n  document.getElementById(`header-link-start`).className = \"not-active\";\r\n  document.getElementById(`header-link-stairs`).className = \"not-active\";\r\n  document.getElementById(`header-link-maze`).className = \"not-active\";\r\n  document.getElementById(`header-link-clear`).className = \"not-active\";\r\n  var grid = document.getElementsByClassName(`grid`);\r\n  grid[0].classList.add(\"not-active\");\r\n  setTimeout(() => {\r\n    document.getElementById(`header-link-start`).className = \"\";\r\n    document.getElementById(`header-link-stairs`).className = \"\";\r\n    document.getElementById(`header-link-maze`).className = \"\";\r\n    document.getElementById(`header-link-clear`).className = \"\";\r\n    grid[0].classList.remove(\"not-active\");\r\n  }, 20 * (mappedLength + finalPathLength + 40));\r\n};\r\n","import React, { PureComponent, createRef } from \"react\";\nimport Header, { isWeightAvailable } from \"./header/Header.js\";\nimport \"./App.css\";\nimport GridView from \"../pathfinder/gridView/GridView.jsx\";\nimport { setGrid } from \"../pathfinder/grid/Grid.js\";\nimport { stairs } from \"../pathfinder/mazes/StairGenerator.js\";\nimport { randomizedMaze } from \"../pathfinder/mazes/MazeGenerator.js\";\nimport { breadthFS } from \"../pathfinder/algos/BreadthFS.js\";\nimport { dijkstra } from \"../pathfinder/algos/Dijkstra.js\";\nimport { depthFS } from \"../pathfinder/algos/DepthFS.js\";\nimport { Astar } from \"../pathfinder/algos/Astar.js\";\nimport { bestFS } from \"../pathfinder/algos/BestFS.js\";\nimport {\n  animateSearch,\n  animatePath,\n  animateGenerated,\n  deanimateGeneratedAfter,\n  notActive,\n  recalcAlgo,\n  isWeightOnGrid,\n} from \"../pathfinder/gridView/algoAnimator.js\";\n\n/* \"CONTROLLER\" */\n// Controls communication between grid model and grid view */\nexport default class App extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [], // [][] of Nodes\n      clear: false,\n      algoDisplayed: false,\n      algoSelected: \"dijkstra\",\n      generated: false,\n    };\n    this.gridRef = createRef();\n    this.maxRow = 0;\n    this.maxCol = 0;\n    this.start_row = 0;\n    this.start_col = 0;\n    this.end_row = 0;\n    this.end_col = 0;\n  }\n\n  // Components & functions dependent on lifecycles:\n  componentDidMount() {\n    /* Initiate grid: */\n    /* (dynamically calculate max size of board from window dimensions in View)*/\n    this.gridInit();\n  }\n  componentDidUpdate() {\n    this.setState({ clear: false });\n    this.setState({ generated: false });\n  }\n\n  /* ***************************************************************** */\n  /* ++++++++++++++++++++++ ALGORITHMS HANDLERS ++++++++++++++++++++++ */\n\n  prepareAlgo = () => {\n    this.clearGridBeforeAlgo();\n    if (this.state.algoSelected === \"dijkstra\") {\n      var pathArrays = dijkstra(this.state.grid);\n    } else if (this.state.algoSelected === \"astar\") {\n      pathArrays = Astar(this.state.grid);\n    } else if (this.state.algoSelected === \"bestfs\") {\n      pathArrays = bestFS(this.state.grid);\n    } else if (this.state.algoSelected === \"breadthfs\") {\n      pathArrays = breadthFS(this.state.grid);\n    } else if (this.state.algoSelected === \"depthfs\") {\n      pathArrays = depthFS(this.state.grid);\n    }\n    return pathArrays;\n  };\n\n  startAlgo = () => {\n    const pathArrays = this.prepareAlgo();\n    animateSearch(pathArrays.mappedFunction);\n    animatePath(pathArrays.finalPath, pathArrays.mappedFunction);\n    notActive(pathArrays.finalPath, pathArrays.mappedFunction);\n    this.setState({ algoDisplayed: true });\n  };\n\n  recalculateAlgo = () => {\n    const pathArrays = this.prepareAlgo();\n    recalcAlgo(pathArrays.finalPath, pathArrays.mappedFunction);\n    this.setState({ algoDisplayed: true });\n  };\n\n  chooseAlgo = (algoType) => {\n    this.setState({ algoSelected: algoType }, () => {\n      if (!isWeightAvailable(this.state.algoSelected)) {\n        if (isWeightOnGrid(this.state.grid, this.maxCol, this.maxRow)) {\n          this.clearGrid();\n        }\n      }\n    });\n  };\n\n  weightedAlgo = () => {\n    return isWeightAvailable(this.state.algoSelected);\n  };\n\n  // ---------------- MAZES & PATTERNS ----------------- //\n  // STAIRS\n  generateStairs = () => {\n    this.clearGridBeforeAlgo();\n    this.clearGrid();\n    setTimeout(() => {\n      const [stairsMapped, stairsGrid] = stairs(this.state.grid);\n      animateGenerated(stairsMapped);\n      setTimeout(() => {\n        this.setState({ grid: stairsGrid }, () => {\n          this.setState({ generated: true }, () => {\n            deanimateGeneratedAfter();\n          });\n        });\n      }, 20 * (stairsMapped.length + 40));\n    }, 20);\n  };\n\n  // MAZE\n  generateMaze = () => {\n    this.clearGridBeforeAlgo();\n    this.clearGrid();\n    setTimeout(() => {\n      const [mazeMapped, mazeGrid] = randomizedMaze(this.state.grid);\n      animateGenerated(mazeMapped);\n      setTimeout(() => {\n        this.setState({ grid: mazeGrid }, () => {\n          this.setState({ generated: true }, () => {\n            deanimateGeneratedAfter();\n          });\n        });\n      }, 20 * (mazeMapped.length + 40));\n    }, 20);\n  };\n\n  isWall = (col, row) => {\n    return this.state.grid[row][col].locator === \"wall\" ? true : false;\n  };\n\n  /* ******************* Methods for GRID handling ******************* */\n  /* ***************************************************************** */\n  // Get basic props of grid for initialization\n  getRowCol = (maxRow, maxCol, st_row, st_col, en_row, en_col) => {\n    this.maxRow = maxRow;\n    this.maxCol = maxCol;\n    this.start_row = st_row;\n    this.start_col = st_col;\n    this.end_row = en_row;\n    this.end_col = en_col;\n  };\n  // Initialize grid\n  gridInit = () => {\n    const newGrid = setGrid(\n      this.maxRow,\n      this.maxCol,\n      this.start_row,\n      this.start_col,\n      this.end_row,\n      this.end_col\n    );\n    this.setState({ grid: newGrid });\n  };\n  /* +++++++++++++++++ GRID UPDATE +++++++++++++++++ */\n  gridUpdate = (j, i, loc) => {\n    // Update grid by utilizing input from mouse handlers\n    /* Mutates grid state directly (to avoid unnecessary re-rendering of thousands of nodes) */\n    /* Synchronizes grid view and logic */\n    const newGrid = this.state.grid.slice();\n    const node = newGrid[i][j];\n    const newNode = {\n      ...node,\n      locator: loc,\n    };\n    newGrid[i][j] = newNode;\n    this.state.grid = newGrid;\n    //this.setState({ grid: newGrid });\n  };\n\n  /* +++++++++++++++ CLEAR FULL GRID +++++++++++++++ */\n  clearGrid = async () => {\n    // Clear GridView -> NodeView\n    this.setState({ clear: true });\n\n    // Clear Grid -> Node\n    const newGrid = this.state.grid.slice();\n    for (var i = 0; i < this.maxCol; i++) {\n      for (var j = 0; j < this.maxRow; j++) {\n        // Reset every Node to initial state\n        var node = newGrid[j][i];\n        var loc = node.locator;\n        if (\n          loc === \"wall\" ||\n          loc === \"weight\" ||\n          loc === \"path\" ||\n          loc === \"algo\"\n        ) {\n          loc = \"\";\n        }\n        const newNode = {\n          ...node,\n          type: \"norm\",\n          locator: loc,\n        };\n        newGrid[j][i] = newNode;\n        if (node.locator === \"path\" || node.locator === \"algo\") {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node norm\";\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node norm \" + node.locator;\n        }\n      }\n    }\n    this.setState({ grid: newGrid, algoDisplayed: false });\n  };\n\n  /* +++++++++++ CLEAR GRID BEFORE ALGO +++++++++++ */\n  // Clears only algo vars: isVisited, previousNode, distance\n  clearGridBeforeAlgo = () => {\n    // Clear Grid -> Node\n    const newGrid = this.state.grid.slice();\n    for (var i = 0; i < this.maxCol; i++) {\n      for (var j = 0; j < this.maxRow; j++) {\n        // Reset every Node to initial state\n        var node = newGrid[j][i];\n        const newNode = {\n          ...node,\n          isVisited: false,\n          previousNode: null,\n          distance: Infinity,\n          totalDistance: Infinity,\n        };\n        newGrid[j][i] = newNode;\n        if (node.locator === \"path\" || node.locator === \"algo\") {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node norm\";\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node norm \" + node.locator;\n        }\n        if (node.locator === \"weight\") {\n          document.getElementsByClassName(`hand-path`).className = \"hand\";\n        }\n      }\n    }\n    this.setState({ grid: newGrid, algoDisplayed: false });\n  };\n\n  /* *********************************************************************** */\n  /* ************************ Render header & grid ************************* */\n\n  render() {\n    return (\n      <div>\n        <Header\n          clearBoard={this.clearGrid}\n          algo={this.startAlgo}\n          generateStairs={this.generateStairs}\n          generateMaze={this.generateMaze}\n          algoSelected={this.chooseAlgo}\n        />\n\n        <div className=\"full-grid\">\n          <GridView\n            ref={this.gridRef}\n            gridMax={this.getRowCol}\n            gridUpdate={this.gridUpdate}\n            clear={this.state.clear}\n            algoDisplayed={this.state.algoDisplayed}\n            algoRecalculate={this.recalculateAlgo}\n            generated={this.state.generated}\n            isWall={this.isWall}\n            weighted={this.weightedAlgo}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n","import { createNode } from \"./Node.js\";\r\n\r\nexport const setGrid = (\r\n  maxRow,\r\n  maxCol,\r\n  start_row,\r\n  start_col,\r\n  end_row,\r\n  end_col\r\n) => {\r\n  const grid = [];\r\n\r\n  const initializeGrid = () => {\r\n    var count = 0;\r\n    for (var i = 0; i < maxRow; i++) {\r\n      var nodeRows = [];\r\n      for (var j = 0; j < maxCol; j++) {\r\n        var locator = setLocators(j, i, start_row, start_col, end_row, end_col);\r\n        const node = createNode(i, j, locator, count);\r\n        nodeRows.push(node);\r\n        count++;\r\n      }\r\n      grid.push(nodeRows);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  // Place locators on the grid\r\n  const setLocators = (j, i, start_row, start_col, end_row, end_col) => {\r\n    var locatorProp = \"\";\r\n\r\n    if (j === start_row && i === start_col) {\r\n      locatorProp = \"start\";\r\n      //console.log(\"loc start GR: r/c: \" + start_row + \" \" + start_col);\r\n    }\r\n    if (j === end_row && i === end_col) locatorProp = \"end\";\r\n    //console.log(\"loc end GR: r/c: \" + end_row + \" \" + end_col);\r\n    return locatorProp;\r\n  };\r\n\r\n  return initializeGrid();\r\n};\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { render } from \"react-dom\";\nimport { transitions, positions } from \"react-alert\";\nimport \"./index.css\";\nimport App from \"./app/App.js\";\nimport * as serviceWorker from \"./app/serviceWorker\";\n\n// optional configuration\nconst options = {\n  // you can also just use 'bottom center'\n  position: positions.BOTTOM_CENTER,\n  timeout: 5000,\n  offset: \"30px\",\n  // you can also just use 'scale'\n  transition: transitions.SCALE,\n};\n\nReactDOM.render(\n  //<React.StrictMode>\n  <App />,\n  //</React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/dot_full.f7c48a77.svg\";","module.exports = __webpack_public_path__ + \"static/media/start.d9d208a8.svg\";","module.exports = __webpack_public_path__ + \"static/media/flag.7228ac6a.svg\";","module.exports = __webpack_public_path__ + \"static/media/hold.608d80cd.svg\";"],"sourceRoot":""}